# Arrays, Range, Tuple, Dict
This section contains some important data types in Julia that can hold multiple values.
Such data types are called *collections*.
## Arrays
Similarly to the *string*, an *array* is an ordered sequence of values.
While the string consists of *char* type values, arrays can contain all possible types of values.
The values in an array are called *elements*.

Arrays can be created in various ways.
Writing all elements separated by a comma within square brackets is the simplest one:
```julia;results="hidden"
primes = [2, 3, 5, 7, 11, 13]
baustoffe = ["Holz", "Beton", "Stahl"]
```

The first line creates array of six integers, the second line creates array of three strings.
However, the elements of an array do not have to be the same type; even arrays within arrays are possible:
```julia;results="hidden"
stahl = ["S235", 235.0, [10, 20]]
```
With `typeof()` the type of an array can be retrieved:
```julia; term=true
typeof(primes)
typeof(baustoffe)
typeof(stahl)
```
Inside the curly brackets, the data type of the array is written first, then follows the order of the array.
An *empty array* has no elements and can be created e.g. with empty square brackets (`[]`).
Such empty array is of type `Array{Any,1}`.
An empty array with values of a certain type, such as `Float64`, can be created using `Array{Float64,1}()` or `Float64[]`; however, with the notation `Float64[]` only first-order arrays can be created.
```julia; term=true
[]
Array{Float64,1}()
Float64[]
```

### Arrays can be modified
The syntax for accessing a particular element of an array is the same as for accessing a character within a string: the array is immediately followed by an integer, as an index, in square brackets.
```julia; term=true
baustoffe[2]
```

As with strings, sequence of an array can also be accessed:
```julia; term=true
primes[2:4]
primes[3:end]
```

Unlike strings, however, arrays are modifiable.
That means, single elements or sections of an array can be reassigned by the `=` operator.
The newly assigned data type must match the type of the array.
```julia; term=true
baustoffe[3] = "Ziegel"
baustoffe[2] = 2
print(baustoffe)
```

With this regard, the following behavior might be confusing:
```julia; term=true
a = [1, 4, 3];  # create array a
b = a;  # assign array a to b
b[2] = 2;  # replace the second element of b
print("a = $(a)")  # a array was changed as well
print("b = $(b)")
```
Changing the value in the array `b` changes also the array `a`.
This is because the expression `b = a` does **not** copy the array `a`, but refers to it.
In order to copy an array, `copy()` is the appropriate function.
```julia; term=true
a = [1, 4, 3];  # create array a
b = copy(a);  # save copy of a in b
b[2] = 2;  # replace second value in b
print("a = $(a)")  # a stays the same
print("b = $(b)")
```

### Functions of the Array Library
`length` returns the number of elements of the array.
An array in another array is one element.
```julia; term=true
print(primes)
length(primes)
print(stahl)
length(stahl)
length(stahl[3])
```

`push!` inserts a new element at the end of the array:
```julia; term=true
fib = [1, 1, 2, 3, 5];
push!(fib, 8);
print(fib)
```

`append!` appends an array to the end of the array:
```julia; term=true
append!(fib, [13, 21, 34]);
print(fib)
```

`insert!` inserts an element at a given index into the array:
```julia; term=true
countdown = [5, 4, 3, 1, 0];
insert!(countdown, 4, 2);  # the number 2 is inserted in the fourth position
print(countdown)
```

`sort!` sorts the elements of an array from the lowest to the highest value:
```julia; term=true
c = ['d', 'g', 'a', 'W', 'f'];
sort!(c);
print(c)
```

`sort`, on the other hand, creates a **sorted copy** of the array:
```julia; term=true
c1 = ['d', 'g', 'a', 'W', 'f'];
c2 = sort(c1);
print("c1 = $(c1)")
print("c2 = $(c2)")
```

It has become common in Julia, that functions which directly modify their argument end with `!`.

### Delete elements
There are several ways to delete individual elements from an array.
`pop!` removes the last element from the array and returns this element:
```julia; term=true
chars = ['a', 'b', 'c'];
pop!(chars)
print(chars)
```

The first element of an array can be removed using `popfirst!`:
```julia; term=true
chars = ['a', 'b', 'c'];
popfirst!(chars)
print(chars)
```

If the element's index is known, it can be removed from the array using `splice!`:
```julia; term=true
chars = ['a', 'b', 'c'];
splice!(chars, 2)
print(chars)
```

The `deleteat!` works in similar way.
However here, the array is returned instead of the deleted element:
```julia; term=true
chars = ['a', 'b', 'c'];
deleteat!(chars,2)
print(chars)
```

### Strings and Arrays
Strings and arrays are similar in some aspects.
A string is a sequence of characters; since an array can be filled with any data type, an array of characters is also a sequence of characters.
Nevertheless, both are different data types with different properties.
`collect`  converts a string into an array of characters:
```julia; term=true
a = collect("spam");
print(a)
```

By means of `split` a string can be separated into several parts by desired delimiter.
For example, sentences can be split into individual words:
```julia; term=true
s1 = split("Julia ist großartig")  # by default it is separated at every whitespace
s2 = split("Stahl;Beton;Ziegel;Holz",';')  # The second argument is the delimiter
```

`join` joins an array of strings to a single string:
```julia; term=true
s1 = split("julia ist großartig")
sort!(s1)
s2 = join(s1,' ')
```

### Higher order arrays
For many numerical tasks, it is helpful to use second or higher order arrays.
In Julia, a second order array is also called *matrix*.
The input is similar to the first order arrays in square brackets, but the elements are entered row by row with spaces between the elements of a row and semicolons between the rows.
As an alternative, a newline can be inserted instead of the semicolons.
```julia; results="hidden"
a = [1 2; 3 4]
b = [4 2
     3 1]
```

An `m×n` matrix has `m` rows and `n` columns.
An element of the matrix is accessed with the syntax `matrix[m,n]`.
In the same way, parts of the matrix can be accessed.
A colon `:` without indices denotes the entire row or column.
```julia; term=true
m = rand(3,6)
m[2,3]  # second row, third column
m[1:2,6]  # first and second rows, sixth column
m[3,:]  # third row, all columns
```

The function `rand` generates random numbers in different manner.
A single random number is generated from the interval $[0,1)$, when no argument is used.
However, integers can be used as the input arguments to generate a higher order array of random numbers.
Here, the first number specifies the number of elements in first order, the second number specifies the number of elements in second order, and so on.
So `rand(3, 2, 4)` creates an `3×2×4` third order array, full of random numbers between 0 and 1.
```julia; term=true
rand()
rand(2)
rand(2,2)
rand(3,2,4)
```

The function `rand` does not only generates random numbers between `0` und `1`, but it is also possible to randomly select an element from an `Array`.
The array has to be on the first position of the function argument, after that any number of `integers` can be inserted as the number of elements per order.
```julia;term=true
a = ["Holz","Stahl","Ziegel","Beton"];
rand(a)
rand(a,3)
rand(a,2,3)
```

The function `zero` can be applied not only to numbers, but also to arrays of numbers.
In this context, the functions `one`, `ones` and `zeros` are also interesting.
Attention: with `one` the argument has to be a square matrix.
```julia;term=true
a = [1 2; 3 4]
zero(a)  # Creates an array full of zeros, the same size as the argument
one(a)  # Creates a identity matrix with size equal to the argument
zeros(2,3)  # Creates a 2x3 array full of zeros
ones(3,2)  # Creates 3x2 array of all ones
```

`similar` creates an array of the same data type as the given argument.
```julia;term=true
a = [1 2; 3 4];
b = ["a" "b"; "c" "d"];
similar(a)
similar(b)
```

### Broadcasting
Many operations in Julia can be applied to arrays element by element.
This procedure is also called *broadcasting*.
For this purpose, operators like `+` and `^` are preceded by `.` or functions are followed by `.`:
```julia; term=true
a = [1 2 3; 3 4 5]
a .^2
a .+ 4
b = ["Tom" "Jerry"; "Michael" "John"];
length.(b)
```

When applying comparison operators or functions which return the `Bool` data type, a bit array (consists only of `0` and `1`, for `false` and `true`) is created by means of *Broadcasting* to all elements of the array. 
Based on this, it is possible to access some parts of the array.
This is done in a way, that the elements with `Bool` value `1` are selected only.
 

```julia; term=true
primes .>= 10
primes[primes .>= 10]
occursin.("o",b) # String which contains o
b[occursin.("o",b)]
```

## Range
A `range` is a series of `integer` numbers.
The `range` can be created by means of specifying the first and last number of the sequence separated by a colon `:`.
The step size is defined as `1` by default.
The step size can be defined by specifying the third `integer` number.
The step size can also be negative for a descending `range`, but then the larger value must be in the first position.
```julia;term=true
1:10
0:2:10
10:-2:0  # Negative step sizes create descending ranges
```

`rand` can be also applied to the `Range`.
```julia;term=true
rand(1:10)
print(sort(rand(1:45,6)))  # The lotto numbers for next week?
```

A `range` can be useful especially for loops.
Arrays can be also quickly created by function `collect`. 
```julia;term=true
print(collect(1:5))
print(collect(6:-2:0))
```

Julia has implemented several types of collections.
Many of these collections can be converted to arrays using `collect`.

`Range` can be used to access parts of an array as well.

```julia; term=true
primes[1:2:end]
primes[end:-1:1]
```

## Tuple
The data type `tuple` is very similar to the first order array.
The most important difference is that `tuples` are not modifiable.
The easiest way to create a tuple is to enter several values separated by commas.
However, the good practice is to surround the values with round brackets:
```julia;term=true
t1 = 1, 2, 3, 4
t2 = ('a', 'b', 'c')
```

As with the arrays, different data types can be written to a tuples as well.
The data types are written in the data type of the tuple:
```julia; term=true
t = (1, 3.1415, "foo", ('c',))
typeof(t)
```

Tuples with only one element must be terminated with a comma.
An empty tuple can be created with `tuple()`.
```julia; term=true
t1 = ('!',)  # Tuple
c = ('!')  # Character
t2 = tuple()
```

Similarly to arrays, single or multiple elements of a tuple can be accessed using square brackets.
However, since a tuple is not modifiable, Julia returns a *MethodError* when trying to redefine a value in tuple.
```julia;term=true
t = (2, 3, 5, 7, 11, 13, 17, 19)
print(t[3])
print(t[4:6])
print(t[5:end])
t[4] = 23
```

Sometimes it is necessary to convert a `tuple` into an `array`, e.g. to be able to change values.
By means of `collect` a `tuple` can easily be converted into an `array`:
```julia;term=true
print(collect(("spam", "foo", "bar")))
```

## Dictionaries
A `Dict` (abbreviation for *Dictionary*) is also very similar to the first order array.
While the indices of an array are limited to integers, the indices of a *dictionary* can be almost any data type.
The indices of a dictionary are called *Keys* and the values are called *Values*.
Each value is assigned to the key.
With a dictionary e.g. a dictionary can be created, in which each key is a German word, to which the suitable Spanish word is assigned.
With `Dict()` a dictionary is created:
```julia; term=true
de2sp = Dict("eins" => "uno", "zwei" => "dos", "drei" => "tres")
```
Another important difference from arrays is that dictionaries are not ordered.
Therefore, the elements may not be displayed in the order entered.

The syntax for entering key-value pairs is as follows:
  - a key-value pair consists of the key followed by `=>` and the corresponding value;
  - the individual entries are separated by a comma.
The values can be accessed by using square brackets and entering an index.
If the entered index does not exist in the dictionary, Julia returns a *KeyError*.
```julia; term=true
de2sp["zwei"]
de2sp["vier"]
```

This should be changed.
New indexes can be added in the following way:
```julia; term=true
de2sp["vier"] = "cuatro"
print(de2sp)
```

In this way existing values can be redefined.
The functions `keys` and `values` return collections with the keys or values of a dictionary.
```julia; term=true
print(keys(de2sp))
print(values(de2sp))
```

These collections have the types `Base.KeySet` and `Base.ValueIterator`, which we will not discuss in detail here.
However, it should be noted that these collections have different properties than arrays and therefore some operations are not possible with them.
Again, `collect` offers the possibility to convert these collections into `arrays`:
```julia;term=true
print(collect(keys(de2sp)))
```

## Assignments
### Merge three arrays together
Write a function `connect_three` that takes three arrays as arguments and joins these arrays into one array.
The function has to work only for arrays with the same data type (e.g. three times Array{String,1} or three times Array{Any,1}).
```julia; results="hidden"; echo=false
function connect_three(a,b,c)
    return append!(append!(a,b),c)
end
```

Example:
```julia;term=true
a = [1, 1, 2];
b = [3, 5];
c = [8, 13];
print(connect_three(a,b,c))
```

### Inner values of an array
Write a function `interior` that takes an array as argument and returns a new array containing all values except the first and the last.
If the array has less than three elements, an empty array should be returned.
Note: A very simple solution without if statement can be formulated using access to a section of the array.
```julia; results="hidden"; echo=false
function interior(a)
    return a[2:end-1]
end
```

Examples:
```julia;term=true
nums = [0,1,2,3,4];
res1 = interior(nums)
res2 = interior(res1)
res3 = interior(res2)
```

### Is the array sorted?
Write a function `is_sort` that takes an array as argument, checks if this array is sorted, and returns `true` or `false` accordingly.
```julia; results="hidden"; echo=false
function is_sort(a)
    return a == sort(a)
end
```

Examples:
```julia;term=true
unsorted_nums = [3,2,5,1];
sorted_nums = sort(unsorted_nums);
is_sort(unsorted_nums)
is_sort(sorted_nums)
```

### Anagram-Test
Two words are anagrams if the letters of one word can be rearranged to create another word.
Write a function `is_anagram` that takes two strings as arguments, checks whether these strings are anagrams, and returns `true` or `false` accordingly.
The function is not case-sensitive (`stone` is equivalent to `stone`).
```julia;results="hidden";echo=false
function is_anagram(s1, s2)
    return sort(collect(lowercase(s1))) == sort(collect(lowercase(s2)))
end
```

Examples:
```julia;term=true;
is_anagram("spam","eggs")
is_anagram("Stein","niest")
```

### Return the Nth element of a dict
Since dictionaries are not ordered, Julia does not provide a way to access the `n`th element of a dict.
Write a function `dict_index(d,n)` that takes a dict `d` and an integer `n` as arguments, sorts the dictionary by the keys, and returns the `n`th value in that order.
```julia; results="hidden"; echo=false
function dict_index(d, n)
    return d[sort(collect(keys(d)))[n]]
end
```

Examples:
```julia;term=true
d = Dict("a"=>1,"b"=>2, "c"=>3, "d"=>4)
dict_index(d, 2)
```

### Merge Tuples
Because tuples are not modifiable, two tuples cannot be merged by default.
Write a function `tuple_append` that takes two tuples as arguments, appends the second to the first, and returns the merged tuple as Return Value.
```julia; results="hidden"; echo=false
function tuple_append(t1, t2)
    return Tuple(append!(collect(t1),collect(t2)))
end
```

Examples:
```julia;term=true
t1 = ('a','b')
t2 = ('c','d','e')
tuple_append(t1,t2)
```
